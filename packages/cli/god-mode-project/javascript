// filename:src/components/TodoService.js
import React, { useState, useEffect, useCallback } from 'react';
import { v4 as uuidv4 } from 'uuid'; // Assuming UUID library is installed

/**
 * Custom hook for managing todo items with CRUD operations.
 * 
 * Functions:
 * - fetchTodos: Fetches all todos from the "database".
 * - createTodo: Creates a new todo item.
 * - updateTodo: Updates an existing todo item.
 * - deleteTodo: Deletes a todo item.
 * - toggleTodo: Toggles the completion status of a todo item.
 * - clearCompleted: Clears all completed todos.
 * 
 * State:
 * - todos: Array of todo items.
 * - loading: Boolean indicating loading state.
 * - error: Error message string.
 * 
 * Computed Properties:
 * - completedTodos: Array of completed todo items.
 * - activeTodos: Array of active todo items.
 * - totalTodos: Total number of todo items.
 */
const useTodoService = () => {
  const [todos, setTodos] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Simulate database operations with proper error handling
  const simulateDatabaseCall = async (operation, data = null) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          if (Math.random() < 0.05) {
            throw new Error(`Database ${operation} failed`);
          } else {
            resolve(data);
          }
        } catch (error) {
          reject(error);
        }
      }, 100);
    });
  };

  const fetchTodos = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const dbTodos = await simulateDatabaseCall('fetch', [
        { id: uuidv4(), title: 'Learn React', completed: true },
        { id: uuidv4(), title: 'Build Todo App', completed: false },
        { id: uuidv4(), title: 'Deploy to Production', completed: false }
      ]);
      setTodos(dbTodos);
    } catch (err) {
      setError(err.message);
      console.error('Failed to fetch todos:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  const createTodo = useCallback(async (title) => {
    if (!title || title.trim() === '') {
      throw new Error('Todo title cannot be empty');
    }
    setError(null);
    const newTodo = {
      id: uuidv4(),
      title: title.trim(),
      completed: false,
      createdAt: new Date().toISOString()
    };
    try {
      await simulateDatabaseCall('create', newTodo);
      setTodos(prev => [...prev, newTodo]);
    } catch (err) {
      setError(err.message);
      console.error('Failed to create todo:', err);
      throw err;
    }
  }, []);

  const updateTodo = useCallback(async (id, updates) => {
    if (!id) {
      throw new Error('Todo ID is required for update');
    }
    setError(null);
    try {
      await simulateDatabaseCall('update', { id, ...updates });
      setTodos(prev => prev.map(todo => 
        todo.id === id ? { ...todo, ...updates, updatedAt: new Date().toISOString() } : todo
      ));
    } catch (err) {
      setError(err.message);
      console.error('Failed to update todo:', err);
      throw err;
    }
  }, []);

  const deleteTodo = useCallback(async (id) => {
    if (!id) {
      throw new Error('Todo ID is required for deletion');
    }
    setError(null);
    try {
      await simulateDatabaseCall('delete', id);
      setTodos(prev => prev.filter(todo => todo.id !== id));
    } catch (err) {
      setError(err.message);
      console.error('Failed to delete todo:', err);
      throw err;
    }
  }, []);

  const toggleTodo = useCallback(async (id) => {
    const todo = todos.find(t => t.id === id);
    if (todo) {
      await updateTodo(id, { completed: !todo.completed });
    }
  }, [todos, updateTodo]);

  const clearCompleted = useCallback(async () => {
    setError(null);
    try {
      await Promise.all(todos.filter(todo => todo.completed).map(todo => simulateDatabaseCall('delete', todo.id)));
      setTodos(prev => prev.filter(todo => !todo.completed));
    } catch (err) {
      setError(err.message);
      console.error('Failed to clear completed todos:', err);
      throw err;
    }
  }, [todos]);

  useEffect(() => {
    fetchTodos();
  }, [fetchTodos]);

  return {
    todos,
    loading,
    error,
    createTodo,
    fetchTodos,
    updateTodo,
    deleteTodo,
    toggleTodo,
    clearCompleted,
    completedTodos: todos.filter(todo => todo.completed),
    activeTodos: todos.filter(todo => !todo.completed),
    totalTodos: todos.length
  };
};

const withTodoService = (Component) => (props) => {
  const todoService = useTodoService();
  return <Component {...props} todoService={todoService} />;
};

export { useTodoService, withTodoService };
export default useTodoService;